{
    parserClass = "dejavu.psi.parser.YggdrasilParser"
    parserUtilClass = "dejavu.psi.ParserExtension"

    extends = "dejavu.psi.DejavuElement"

    psiClassPrefix = "Dejavu"
    psiImplClassSuffix = "Node"
    psiPackage = "dejavu.psi.node"
    psiImplPackage = "dejavu.psi.node"

    elementTypeHolderClass = "dejavu.psi.DejavuTypes"
    elementTypeClass = "dejavu.psi.DejavuElementType"
    tokenTypeClass = "dejavu.psi.DejavuTokenType"

    psiImplUtilClass = "dejavu.psi.node.DejavuPsiExtension"

    tokens = [
        // comment
        COMMENT_LINE = "Comment"
        COMMENT_BLOCK = "Comment Block"

        // literal
        URL = "Url"
        SYMBOL    = "Symbol"
        ESCAPED   = "\escaped"
        INTEGER   = "<<INTEGER>>"

        REFERENCE = "$Symbol"

        SELECTION_LINE = "SELECTION_LINE"


        KW_GRAMMAR = "grammar"
        KW_USING = "using"
        KW_GROUP = "group"
        KW_CLASS = "class"
        KW_UNION = "union"
        KW_CLIMB = "climb"
        KW_IMPORT = "import"
        KW_AS = "as"
        KW_MACRO = "macro"

		VERSION = "<<semver>>"
        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ANGLE_L = '<'
        ANGLE_R = '>'
        OP_REMARK = '^'
        EQ = '='
        COLON = ':'
        SEMICOLON = ';'
        COMMA = ','
        DOLLAR = '$'
        DOT = '.'
        OP_MANY = '*'
        AT = '@'
        TO = "->"
        HYPHEN = "-"
        SLASH = '/'
        OP_OR = '|'
        OP_CONCAT = '~'
        PLACE_HOLDER = "_"
//      SPACE='regexp:\s+'
//      ANY = 'regexp:.'

    ]
}

// https://github.com/bytecodealliance/fluent/blob/master/spec/fluent.ebnf
root ::= text-elements*
text-elements ::=
    declaration-template
  | if-element
  | while-element
  | for-element
  | match-element
  | slot-element
  | invoke-element
  | WHITE_SPACE
  | NORMAL_TEXT;

declaration-template  ::= TEMPLATE_L KW_TEMPLATE identifier? declaration-element* TEMPLATE_R;
declaration-element ::=
    implement-element
  | extends-element
  | SEMICOLON

implement-element ::= KW_IMPLEMENTS identifier;
extends-element ::= KW_EXTENDS identifier;

// === if statement ===
if-element        ::= if-statement else-if-statement* else-statement? template-end;
if-statement      ::= template-if text-elements*;
else-if-statement ::= template-else-if text-elements*;
else-statement    ::= template-else text-elements*;

template-if       ::= TEMPLATE_L KW_IF expression TEMPLATE_R {
    pin = 2
}
template-else     ::= TEMPLATE_L KW_ELSE TEMPLATE_R {
    pin = 2
}
template-else-if  ::= TEMPLATE_L KW_ELSE KW_IF expression TEMPLATE_R {
    pin = 3
}
// === while statement ===
while-element   ::= while-statement else-statement? template-end;
while-statement ::= template-while text-elements*;

template-while  ::= TEMPLATE_L KW_WHILE expression TEMPLATE_R {
    pin = 2
}
// === for statement ===
for-element   ::= for-statement else-statement? template-end;
for-statement ::= template-for text-elements*;

template-for  ::= TEMPLATE_L KW_FOR identifier KW_IN expression TEMPLATE_R {
    pin = 2
}
// === match statement ===
match-element   ::= match-statement match-branch* template-end;
match-statement ::= template-match WHITE_SPACE*;
match-branch    ::=
    case-statement
  | when-statement
  | else-statement
when-statement ::= template-when text-elements*;
case-statement ::= template-case text-elements*;

template-match ::= TEMPLATE_L KW_MATCH expression TEMPLATE_R {
    pin = 2
}
template-when ::= TEMPLATE_L KW_WHEN identifier TEMPLATE_R {
    pin = 2
}
template-case ::= TEMPLATE_L KW_CASE identifier TEMPLATE_R {
    pin = 2
}
// === slot statement ===
slot-element ::= template-slot text-elements* template-end {
    mixin = "dejavu.psi.mixin.MixinSlot"
}
template-slot ::= TEMPLATE_L KW_SLOT identifier TEMPLATE_R {
    pin = 2
}



// === for statement ===
invoke-element  ::= template-invoke text-elements* template-end;
template-invoke ::= TEMPLATE_L KW_INVOKE expression TEMPLATE_R {
    pin = 2
}



template-end ::= TEMPLATE_L (KW_END identifier-free? | identifier-free? KW_END) TEMPLATE_R {
    pin = 2
}
// === expression statement ===
expression ::= value;
// === atomic statement ===
value    ::= number | namepath;
// === literals ===
number ::= INTEGER {
//    mixin = "dejavu.psi.mixin.MixinNumber"
}



// === Identifier ===
namepath ::= identifier (PROPORTION identifier)*;
identifier          ::= SYMBOL | SYMBOW_RAW {
    mixin = "dejavu.psi.mixin.MixinIdentifier"
//    methods=[highlight]
}
identifier-free     ::=
    SYMBOL | SYMBOW_RAW
  | KW_WHILE | KW_FOR
  | KW_IF
  | KW_MATCH
  | KW_INVOKE
  | KW_SLOT
{
    extends = identifier
}