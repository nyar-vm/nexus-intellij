{
    parserClass = "dejavu.psi.parser.YggdrasilParser"
    parserUtilClass = "dejavu.psi.ParserExtension"

    extends = "dejavu.psi.DejavuElement"

    psiClassPrefix = "Dejavu"
    psiImplClassSuffix = "Node"
    psiPackage = "dejavu.psi.node"
    psiImplPackage = "dejavu.psi.node"

    elementTypeHolderClass = "dejavu.psi.DejavuTypes"
    elementTypeClass = "dejavu.psi.DejavuElementType"
    tokenTypeClass = "dejavu.psi.DejavuTokenType"

    psiImplUtilClass = "dejavu.psi.node.DejavuPsiExtension"

    tokens = [
        // comment
        COMMENT_LINE = "Comment"
        COMMENT_BLOCK = "Comment Block"

        // literal
        URL = "Url"
        SYMBOL    = "Symbol"
        ESCAPED   = "\escaped"
        INTEGER   = "<<INTEGER>>"

        REFERENCE = "$Symbol"

        SELECTION_LINE = "SELECTION_LINE"


        KW_GRAMMAR = "grammar"
        KW_USING = "using"
        KW_GROUP = "group"
        KW_CLASS = "class"
        KW_UNION = "union"
        KW_CLIMB = "climb"
        KW_IMPORT = "import"
        KW_AS = "as"
        KW_MACRO = "macro"

		VERSION = "<<semver>>"
        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ANGLE_L = '<'
        ANGLE_R = '>'
        OP_REMARK = '^'
        BIND = '='
        COLON = ':'
        SEMICOLON = ';'
        COMMA = ','
        DOLLAR = '$'
        DOT = '.'
        OP_MANY = '*'
        AT = '@'
        TO = "->"
        HYPHEN = "-"
        SLASH = '/'
        OP_OR = '|'
        OP_CONCAT = '~'
        PLACE_HOLDER = "_"
//      SPACE='regexp:\s+'
//      ANY = 'regexp:.'

    ]
}

// https://github.com/bytecodealliance/fluent/blob/master/spec/fluent.ebnf
root ::= text-elements*
text-elements ::=
    declaration-template
  | program-template
  | if-element
  | while-element
  | for-element
  | match-element
  | slot-element
  | invoke-element
  | template-expression
  | WHITE_SPACE
  | NORMAL_TEXT;
// === program statement ===
declaration-template  ::= TEMPLATE_L KW_TEMPLATE namepath? program-element* TEMPLATE_R {
    mixin = "dejavu.psi.mixin.MixinTemplate"
}
program-template ::= TEMPLATE_L KW_PROGRAM program-element* TEMPLATE_R {
    pin = 2
}
program-element ::=
    using-element
  | class-element
  | extends-element
  | let-statement
  | SEMICOLON
// === using statement ===
using-element ::= KW_USING BRACE_L using-alias* BRACE_R {
    pin = 1
//    mixin = "dejavu.psi.mixin.MixinUsing"
}
using-alias  ::= identifier BIND namepath {

}
// === class statement ===
class-element ::= KW_CLASS namepath BRACE_L pair* BRACE_R {
    pin = 1
    mixin = "dejavu.psi.mixin.MixinClass"
}
extends-element ::= KW_EXTENDS (string | namepath) {
    pin = 1
    mixin = "dejavu.psi.mixin.MixinExtends"
}


// === class statement ===
let-statement ::= KW_LET identifier-free BIND expression {
    pin = 1
    mixin = "dejavu.psi.mixin.MixinLet"
    methods = [highlight]
}


// === if statement ===
if-element        ::= if-statement else-if-statement* else-statement? template-end;
if-statement      ::= template-if text-elements*;
else-if-statement ::= template-else-if text-elements*;
else-statement    ::= template-else text-elements*;

template-if       ::= TEMPLATE_L KW_IF expression TEMPLATE_R {
    pin = 2
}
template-else     ::= TEMPLATE_L KW_ELSE TEMPLATE_R {
    pin = 2
}
template-else-if  ::= TEMPLATE_L KW_ELSE KW_IF expression TEMPLATE_R {
    pin = 3
}
// === while statement ===
while-element   ::= while-statement else-statement? template-end;
while-statement ::= template-while text-elements*;

template-while  ::= TEMPLATE_L KW_WHILE expression TEMPLATE_R {
    pin = 2
}
// === for statement ===
for-element   ::= for-statement else-statement? template-end;
for-statement ::= template-for text-elements*;

template-for  ::= TEMPLATE_L KW_LOOP pattern-bare KW_IN expression if-conditional? TEMPLATE_R {
    pin = 2
}
if-conditional    ::= KW_IF expression {
    pin = 1
}
// === match statement ===
match-element   ::= match-statement match-branch* template-end {
    mixin = "dejavu.psi.mixin.MixinMatch"
    methods = [foldPlaceholder]
}
match-statement ::= template-match WHITE_SPACE*;
match-branch    ::=
    case-statement
  | when-statement
  | else-statement
when-statement ::= template-when text-elements*;
case-statement ::= template-case text-elements*;

template-match ::= TEMPLATE_L KW_MATCH expression TEMPLATE_R {
    pin = 2
}
template-when ::= TEMPLATE_L KW_WHEN pattern TEMPLATE_R {
    pin = 2
}
template-case ::= TEMPLATE_L KW_CASE pattern-bare if-conditional? TEMPLATE_R {
    pin = 2
}
// === pattern expressions ===
pattern ::= pattern-tuple | identifier {
    mixin = "dejavu.psi.mixin.MixinPattern"
    methods= [highlight]
}
pattern-tuple ::= PARENTHESIS_L pattern-bare? PARENTHESIS_R;
pattern-bare ::= pattern (COMMA pattern)* COMMA?;
// === slot statement ===
slot-element ::= template-slot text-elements* template-end {
    mixin = "dejavu.psi.mixin.MixinSlot"
    methods= [highlight]
}
template-slot ::= TEMPLATE_L KW_SLOT identifier TEMPLATE_R {
    pin = 2
}



// === for statement ===
invoke-element  ::= template-invoke text-elements* template-end;
template-invoke ::= TEMPLATE_L KW_INVOKE expression TEMPLATE_R {
    pin = 2
}



template-end ::= TEMPLATE_L (KW_END identifier-free? | identifier-free? KW_END) TEMPLATE_R {
    pin = 2
}
// === expression statement ===
template-expression ::= TEMPLATE_L expression TEMPLATE_R {

}
expression ::= term (infix term)*;
term    ::= prefix* value suffix*

infix  ::= OP_EQ | OP_NE | OP_THEN;
prefix ::= OP_REMARK;
suffix ::= dot-call;


dot-call ::= DOT identifier-free argument-list? {
    mixin = "dejavu.psi.mixin.MixinDotCall"
    methods= [highlight]
}


argument-list  ::= PARENTHESIS_L (argument (COMMA argument)* COMMA?)? PARENTHESIS_R {
//    mixin = "dejavu.psi.mixin.MixinTuple"
}
argument ::= (identifier BIND)? expression;
pair ::= identifier BIND expression;


// === atomic statement ===
value    ::= number | string | function-call;
function-call ::= namepath argument-list? {
    mixin = "dejavu.psi.mixin.MixinFunctionCall"
    methods= [highlight]
}
// === literals ===


number ::= INTEGER {
//    mixin = "dejavu.psi.mixin.MixinNumber"
}
string ::= TEXT_SINGLE | TEXT_DOUBLE;


// === Identifier ===
namepath ::= identifier (PROPORTION identifier)* {
    mixin = "dejavu.psi.mixin.MixinNamepath"
    implements = [
        "com.intellij.psi.PsiNameIdentifierOwner"
    ]
}
identifier          ::= SYMBOL | SYMBOW_RAW {
    mixin = "dejavu.psi.mixin.MixinIdentifier"
}
identifier-free     ::=
    SYMBOL | SYMBOW_RAW
  | KW_WHILE | KW_LOOP
  | KW_IF
  | KW_MATCH
  | KW_INVOKE
  | KW_SLOT
{
    extends = identifier
}